# Java 设计模式实现

本项目实现了 23 种经典的 Java 设计模式，并为每种模式提供了清晰且实用的示例。

## 项目结构

```
java-design-patterns/
├── creational-patterns/        # 创建型设计模式
│   ├── abstract-factory/      # 抽象工厂模式
│   ├── builder/              # 建造者模式
│   ├── factory/              # 工厂模式
│   ├── prototype/            # 原型模式
│   └── singleton/            # 单例模式
├── structural-patterns/       # 结构型设计模式
│   ├── adapter/              # 适配器模式
│   ├── bridge/               # 桥接模式
│   ├── composite/            # 组合模式
│   ├── decorator/            # 装饰器模式
│   ├── facade/               # 外观模式
│   ├── flyweight/            # 享元模式
│   └── proxy/                # 代理模式
└── behavioral-patterns/      # 行为型设计模式
    ├── chain-of-responsibility/  # 责任链模式
    ├── command/              # 命令模式
    ├── interpreter/          # 解释器模式
    ├── iterator/             # 迭代器模式
    ├── mediator/             # 中介者模式
    ├── memento/              # 备忘录模式
    ├── observer/             # 观察者模式
    ├── state/                # 状态模式
    ├── strategy/             # 策略模式
    ├── template/             # 模板方法模式
    └── visitor/              # 访问者模式
```

## 设计模式分类

### 创建型模式
1. **抽象工厂模式** - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
2. **建造者模式** - 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
3. **工厂模式** - 定义一个用于创建对象的接口，让子类决定实例化哪一个类
4. **原型模式** - 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
5. **单例模式** - 保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 结构型模式
1. **适配器模式** - 将一个类的接口转换成客户希望的另一个接口
2. **桥接模式** - 将抽象部分与它的实现部分分离，使它们都可以独立地变化
3. **组合模式** - 将对象组合成树形结构以表示“部分-整体”的层次结构
4. **装饰器模式** - 动态地给一个对象添加一些额外的职责
5. **外观模式** - 为子系统中的一组接口提供一个一致的界面
6. **享元模式** - 运用共享技术有效地支持大量细粒度的对象
7. **代理模式** - 为其他对象提供一个代理以控制对这个对象的访问

### 行为型模式
1. **责任链模式** - 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
2. **命令模式** - 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化
3. **迭代器模式** - 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示
4. **中介者模式** - 用一个中介对象来封装一系列的对象交互
5. **备忘录模式** - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
6. **观察者模式** - 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
7. **状态模式** - 允许一个对象在其内部状态改变时改变它的行为
8. **策略模式** - 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换
9. **模板方法模式** - 定义一个操作中的算法骨架，而将一些步骤延迟到子类中
10. **访问者模式** - 表示一个作用于某对象结构中的各元素的操作
11. **解释器模式** - 为语言创建解释器，解释器模式定义了一种语言的文法，并建立一个解释器来解释该语言中的句子。

## 使用方法

1. 克隆仓库：
```bash
git clone https://github.com/wangguangwu/java-design-patterns.git
```

2. 构建项目：
```bash
mvn clean install
```

3. 运行示例：
```bash
mvn exec:java -Dexec.mainClass="com.wangguangwu.patterns.."
```

## 最佳实践

1. **代码结构**：
    - 使用清晰统一的命名规范
    - 遵循 SOLID 原则
    - 保持类职责单一且高内聚
    - 使用接口进行抽象

2. **文档规范**：
    - 所有公共类和方法添加 Javadoc 注释
    - 记录设计模式及其实现思路
    - 包含使用示例说明

3. **测试建议**：
    - 为所有模式编写单元测试
    - 测试边界情况与异常处理
    - 保持较高的代码覆盖率

4. **代码质量**：
    - 使用 Lombok 减少样板代码
    - 遵循 Java 编码规范
    - 实现优雅的异常处理
    - 注重可读性和扩展性

## 贡献指南

1. Fork 本仓库
2. 创建你的功能分支 (`git checkout -b feature/你的功能`)
3. 提交你的更改 (`git commit -m '添加了某某功能'`)
4. 推送到远程分支 (`git push origin feature/你的功能`)
5. 发起 Pull Request 合并请求

## 许可协议

本项目基于 MIT 协议开源，详见 [LICENSE](LICENSE) 文件。

## 鸣谢

- 感谢所有为本项目做出贡献的开发者
- 感谢开源社区提供的宝贵资源与灵感